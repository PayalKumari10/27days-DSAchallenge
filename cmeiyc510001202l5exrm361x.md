---
title: "ğŸ“…Day-16 Striverâ€™s SDE Sheet | Linked List Part 2 | Find intersection point of Y LinkedList, Detect a cycle in Linked List."
seoTitle: "Linked Lists: Intersection & Cycle Detection"
seoDescription: "Explore Linked Lists with intersection and cycle detection methods in Striverâ€™s SDE Sheet. Learn optimal solutions for coding interview preparation"
datePublished: Tue Aug 19 2025 19:43:47 GMT+0000 (Coordinated Universal Time)
cuid: cmeiyc510001202l5exrm361x
slug: day-16-strivers-sde-sheet-linked-list-part-2-find-intersection-point-of-y-linkedlist-detect-a-cycle-in-linked-list
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1755593220832/f8af42e7-89ce-41e1-8f1a-ac5d52fd52ec.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1755632494803/10ba4d2b-09f1-49c0-b0af-09c4780ad274.png
tags: java, coding, hashnode, dsa, coder, techblog, coding-challenge, codenewbies, coding-journey, dsainjava, dsa-series, striver-dsa-sheet, striversa2zdsa, payalkumari11, dsawithpayal

---

> ***Note : <mark>Started my 27-day DSA journey with Striverâ€™s SDE Sheet!</mark>  
> <mark>I will be journaling every day</mark> <mark>â€” recording what I learn, reflecting on it, and sharing it with my network to help fellow learners</mark> <mark>and aspiring developers..</mark> <mark>Learning through videos, resources, and the internet â€” simplifying logic in my own way with real-world connections. Sharing 2 questions daily: brute-force to optimal, clean Java code, time &amp; space complexity, and key patterns.</mark>***

This blog series is for **anyone preparing for coding interviews** â€” whether youâ€™re a beginner or a revision warrior. Letâ€™s grow together! ğŸš€

## Namaste Developers! ğŸ™

**Welcome to Day 16 of my 27-day DSA journey using Striverâ€™s SDE Sheet!**

### 1ï¸âƒ£ **Find intersection of Two Linked Lists**

### ğŸ”¸ Problem Statement:

Given the heads of two singly linked-lists `headA` and `headB`, return *the node at which the two lists intersect*. If the two linked lists have no intersection at all, return `null`.

For example, the following two linked lists begin to intersect at node `c1`:

![](https://assets.leetcode.com/uploads/2021/03/05/160_statement.png align="left")

The test cases are generated such that there are no cycles anywhere in the entire linked structure.

**Note** that the linked lists must **retain their original structure** after the function returns.

**Custom Judge:**

The inputs to the **judge** are given as follows (your program is **not** given these inputs):

* `intersectVal` - The value of the node where the intersection occurs. This is `0` if there is no intersected node.
    
* `listA` - The first linked list.
    
* `listB` - The second linked list.
    
* `skipA` - The number of nodes to skip ahead in `listA` (starting from the head) to get to the intersected node.
    
* `skipB` - The number of nodes to skip ahead in `listB` (starting from the head) to get to the intersected node.
    

The judge will then create the linked structure based on these inputs and pass the two heads, `headA` and `headB` to your program. If you correctly return the intersected node, then your solution will be **accepted**.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png align="left")

```plaintext
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Intersected at '8'
Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png align="left")

```plaintext
Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Intersected at '2'
Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png align="left")

```plaintext
Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Output: No intersection
Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.
```

**Constraints:**

* The number of nodes of `listA` is in the `m`.
    
* The number of nodes of `listB` is in the `n`.
    
* `1 <= m, n <= 3 * 10<sup>4</sup>`
    
* `1 <= Node.val <= 10<sup>5</sup>`
    
* `0 <= skipA <= m`
    
* `0 <= skipB <= n`
    
* `intersectVal` is `0` if `listA` and `listB` do not intersect.
    
* `intersectVal == listA[skipA] == listB[skipB]` if `listA` and `listB` intersect.
    

**Follow up:** Could you write a solution that runs in`O(m + n)`time and use only`O(1)`memory?

## ğŸ’ Real-Life Example

Imagine two friends walking on different paths in a park .

* Friend A starts from Gate A.
    
* Friend B starts from Gate B.
    
* They meet at the **fountain** (intersection).
    

If one friend walks slower, theyâ€™ll take longer. But if both keep walking and switch gates after finishing, theyâ€™ll always meet at the fountain at the same time.

This is exactly what our **two-pointer solution** does.

### ğŸ’ Brute Force

ğŸ“ Idea: Compare each node of list A with every node of list B until we find a match.

Steps:

1. For each node in `listA`, loop through all nodes in `listB`.
    
2. If `A == B` (same memory reference, not just value), thatâ€™s the intersection.
    
3. If no match, return `null`.
    

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        while (a != null) {
            ListNode b = headB;
            while (b != null) {
                if (a == b) return a;  // intersection found
                b = b.next;
            }
            a = a.next;
        }
        return null;
    }
}
```

### ğŸ“Complexity:

* **Time:** O(m \* n) (nested loops, bad for large inputs)
    
* **Space:** O(1) (no extra space)
    

This works but is super slow when `m, n â‰ˆ 30,000`

### ğŸ’ Optimal Approach

ğŸ“ Instead of brute force, we can use **two pointers**.

ğŸ’¡ Trick: If one pointer reaches the end, move it to the start of the other list. This way, they will align and eventually meet at the intersection (or both end up `null` if no intersection).

Steps:

1. Take two pointers `pA` (on listA) and `pB` (on listB).
    
2. Move them one step at a time.
    
3. If a pointer reaches the end, redirect it to the other listâ€™s head.
    
4. They will either meet at the intersection OR both become `null`.
    

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;

        ListNode pA = headA, pB = headB;

        while (pA != pB) {
            pA = (pA == null) ? headB : pA.next;
            pB = (pB == null) ? headA : pB.next;
        }

        return pA; // intersection node OR null
    }
}
```

### Complexity:

* **Time:** O(m + n) âœ… (each pointer traverses both lists at most once)
    
* **Space:** O(1) âœ… (no extra space)
    

Much faster and cleaner!

---

## 2ï¸âƒ£**Linked List Cycle**

### ğŸ”¸ Problem Statement:

Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following theÂ `next`Â pointer. Internally, `pos`Â is used to denote the index of the node thatÂ tail'sÂ `next`Â pointer is connected to.Â **Note that**Â `pos`Â is not passed as a parameter.

ReturnÂ `true` *if there is a cycle in the linked list*. Otherwise, return `false`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png align="left")

```plaintext
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png align="left")

```plaintext
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png align="left")

```plaintext
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
```

**Constraints:**

* The number of the nodes in the list is in the range `[0, 10<sup>4</sup>]`.
    
* `-10<sup>5</sup> <= Node.val <= 10<sup>5</sup>`
    
* `pos` is `-1` or a **valid index** in the linked-list.
    

**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?

### ğŸ’ Real-Life Example

Think of a **circular race track**.

* If two people (one fast and one slow ) are running, then:
    
    * If the track is circular (cycle hai), the fast one will *eventually* lap the slow one.
        
    * If the track is straight (no cycle), the fast one will reach the end and stop, while the slow one never gets caught.
        

This is exactly how we detect a cycle in a linked list!

### ğŸ’ Another Real-World Example

Imagine a **WhatsApp group** where:

* Every person has a "next person" to forward a message.
    
* If the chain of forwards eventually comes back to you (loop) â†’ thatâ€™s a **cycle**.
    
* If messages keep rea
    
* ching new people until nobody is left â†’ thatâ€™s a **non-cyclic list**.
    

In linked lists:

* `HashSet` approach is like **keeping a record of who already got the message**.
    
* `Tortoise & Hare` approach is like **having 2 people forwarding at different speeds** â€“ if they meet again, then obviously a cycle exists!
    

### ğŸ’ Brute Force Approach (Using HashSet)

* Traverse the linked list and keep storing visited nodes in a `HashSet`.
    
* If we ever reach a node that is already in the set â†’ cycle detected.
    
* If we reach `null` â†’ no cycle.
    

```java
class Solution {
    public boolean hasCycle(ListNode head) {
        // For every node, check ahead if cycle exists
        ListNode curr = head;

        while (curr != null) {
            ListNode checker = curr.next;

            // Look ahead from current node
            while (checker != null) {
                if (checker == curr) {
                    return true; // cycle detected
                }
                checker = checker.next;
            }

            curr = curr.next;
        }

        return false; // reached end, no cycle
    }
}
```

### ğŸ’ Complexity :

* **Time Complexity** â†’ `O(nÂ²)`
    
* **Space Complexity** â†’ `O(1)`
    

âš ï¸ Because of `O(nÂ²)` time, this brute force solution will almost always give **TLE** on large test cases.

### ğŸ’ Optimal Approach (Floydâ€™s Cycle Detection / Tortoise & Hare Algorithm)

* Use **two pointers**:
    
    * Slow â†’ moves one step at a time
        
    * Fast â†’ moves two steps at a time
        
* If thereâ€™s no cycle, `fast` will reach `null`.
    
* If thereâ€™s a cycle, `fast` and `slow` will eventually meet.
    

```java
class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;

        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;       // move 1 step
            fast = fast.next.next;  // move 2 steps

            if (slow == fast) {
                return true; // cycle detected
            }
        }
        return false; // no cycle
    }
}
```

### ğŸ’  Complexity:

* #### Time Complexity: **O(N)**
    

Both pointers traverse nodes linearly.

* #### Space Complexity: **O(1)**
    

We use only two pointers, constant extra space.

ğŸ‘‰ This is the **optimal solution** for cycle detection.

---

## âœï¸ Final Notes:

If you're just starting your DSA journey like me, don't worry if you donâ€™t get it perfect the first time.  
**Visualize â†’ Dry Run â†’ Optimize.**  
Stay consistent, and letâ€™s crack every problem from brute to optimal! ğŸ’ª

### ğŸ™ Special Thanks

A heartfelt thank you to [**<mark>Rajvikraaditya Sir</mark>**](https://www.linkedin.com/in/rajstriver/) for creating and sharing such an incredible DSA resource with the community <mark>(takeuforward)</mark>. Your structured approach has made DSA more accessible and less intimidating for thousands of learners like me.

If this helped you, do share it with your fellow DSA learners.  
Comment with your doubts â€” Iâ€™d love to answer and grow together ğŸŒ±

âœï¸ [**Payal Kumari**](https://www.linkedin.com/in/payalkumari10/) ğŸ‘©â€ğŸ’»  
*My 27-Day DSA Journey with Striverâ€™s Sheet! <mark>#dsawithpayal</mark>*

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1755632404392/ae848eb1-ef20-4c3c-a85e-3b4beabae902.jpeg align="center")

%[https://youtu.be/u4FWXfgS8jw] 

%[https://youtu.be/354J83hX7RI]