---
title: "ğŸ“…Day-6 Striverâ€™s SDE Sheet |  Arrays Part 2 Find the Repeating and Missing Number , Count inversions in an array"
seoTitle: "Repeating and Missing Number: Day 6 SDE Sheet"
seoDescription: "Join my 27-day DSA journey tackling "Find the Repeating and Missing Number" and "Count Inversions in an Array." Optimize your coding skills!"
datePublished: Sun Jul 27 2025 16:54:03 GMT+0000 (Coordinated Universal Time)
cuid: cmdlx59n7000002jv6bu31gx2
slug: day-6-strivers-sde-sheet-arrays-part-2-find-the-repeating-and-missing-number-count-inversions-in-an-array
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1753617267189/4f322e22-65ce-41f3-8f48-76475ce10f04.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1753635119758/7739ebc7-fc70-4fda-a4ee-af35404e9918.png
tags: code, java, technology, coding, hashnode, dsa, coding-challenge, coding-journey, dsainjava, dsa-series, striver-dsa-sheet, striversa2zdsa, striversdesheet, payalkumari11, dsawithpayal

---

> ***Note : <mark>Started my 27-day DSA journey with Striverâ€™s SDE Sheet!</mark>  
> <mark>I will be journaling every day</mark> <mark>â€” recording what I learn, reflecting on it, and sharing it with my network to help fellow learners</mark> <mark>and aspiring developers..</mark> <mark>Learning through videos, resources, and the internet â€” simplifying logic in my own way with real-world connections. Sharing 2 questions daily: brute-force to optimal, clean Java code, time &amp; space complexity, and key patterns.</mark>***

This blog series is for **anyone preparing for coding interviews** â€” whether youâ€™re a beginner or a revision warrior. Letâ€™s grow together! ğŸš€

## Namaste Developers! ğŸ™

### **Welcome to Day 6 of my 27-day DSA journey using Striverâ€™s SDE Sheet!**

### 1ï¸âƒ£**Find the repeating and missing numbers**

ğŸ”¸ Problem Statement:

Given an integer array **nums** of size **n** containing values from **\[1, n\]** and **each** value appears **exactly** once in the array, except for **A**, which appears **twice** and **B** which is **missing**.

Return the values **A** and **B**, as an array of size 2, where **A** appears in the **0-th** index and **B** in the **1st** index.

**Note:** You are not allowed to modify the original array.

```plaintext
Examples:
Input: nums = [3, 5, 4, 1, 1]

Output: [1, 2]

Explanation: 1 appears two times in the array and 2 is missing from nums

Input: nums = [1, 2, 3, 6, 7, 5, 7]

Output: [7, 4]

Explanation: 7 appears two times in the array and 4 is missing from nums.
```

**Constraints:**

* n == nums.length
    
* 1 &lt;= n &lt;= 10<sup>5</sup>
    
* n - 2 elements in nums appear exactly once and are valued between \[1, n\].
    
* 1 element in nums appears twice, and is valued between \[1, n\].
    

### ğŸ’ Real-Life Example:

Imagine you're a teacher checking exam roll numbers.  
You expect each student to have a **unique roll number from 1 to n**.  
But by mistake:

* One student **used anotherâ€™s roll number**
    
* One student **missed writing theirs**
    

Now your task is to find:

* **Who repeated?**
    
* **Who is missing?**
    

ğŸ“Œ And noâ€”you **canâ€™t mark on the attendance sheet** (you can't modify the array)!

### ğŸ“Brute Force Approach

### â¡ï¸ Idea:

Check each number from 1 to n:

* Count how many times it appears in the array
    
* If frequency is 2 â†’ thatâ€™s duplicate
    

If frequency is 0 â†’ thatâ€™s missing

```java
class Solution {
    public int[] findMissingRepeatingNumbers(int[] nums) {
        int n = nums.length;
        int[] freq = new int[n + 1];

        // Count frequencies
        for (int num : nums) {
            freq[num]++;
        }

        int repeating = -1, missing = -1;
        // Find which number appears twice and which is missing
        for (int i = 1; i <= n; i++) {
            if (freq[i] == 2) {
                repeating = i;
            } else if (freq[i] == 0) {
                missing = i;
            }
        }

        return new int[]{repeating, missing};
    }
}
```

### ğŸ“Time Complexity: O(n)

### ğŸ“Space Complexity: O(n)

(Extra array used)

ğŸ‘ **Not allowed in interviews** where extra space is restricted.  

### ğŸ’ Optimal Approach â€“ Using Math (Without Modifying Array)

### \=&gt; Smart Trick using **Sum and Sum of Squares**

### Concept:

Let:

* `S` = Sum of first n natural numbers = `n(n+1)/2`
    
* `S2` = Sum of squares of first n natural numbers = `n(n+1)(2n+1)/6`
    

Let `x` be the missing number and `y` be the repeating number.

From given array:

* Let `actualSum = sum of nums`
    
* Let `actualSqSum = sum of squares of nums`
    

Then:

```plaintext
Equation 1: actualSum = S - x + y  â‡’  (y - x) = actualSum - S  
Equation 2: actualSqSum = S2 - xÂ² + yÂ²  â‡’ (yÂ² - xÂ²) = actualSqSum - S2  
```

Now:

* y - x = diff1
    
* yÂ² - xÂ² = (y - x)(y + x) = diff2  
    â‡’ Solve these two equations to find `x` and `y`
    

```java
class Solution {
    public int[] findMissingRepeatingNumbers(int[] nums) {
        int n = nums.length;
        long S = (long) n * (n + 1) / 2;
        long S2 = (long) n * (n + 1) * (2L * n + 1) / 6;

        long actualSum = 0;
        long actualSqSum = 0;
        for (int num : nums) {
            actualSum += num;
            actualSqSum += (long) num * num;
        }

        long diff1 = actualSum - S;       // y âˆ’ x
        long diff2 = actualSqSum - S2;    // yÂ² âˆ’ xÂ²

        long sumYX = diff2 / diff1;       // (y + x)

        long y = (diff1 + sumYX) / 2;     // repeating number
        long x = sumYX - y;               // missing number

        return new int[]{(int) y, (int) x};
    }
}
```

### ğŸ“Time Complexity:

* O(n) âœ…
    

### ğŸ“ Space Complexity:

* O(1) âœ…  
    (No extra space, just variables)
    

ğŸ’ (Hinglish:

* **Math lagao, array mat chhedo** â€“ use sum and sum of squares
    
* **Do equations banao** â€“ y - x and yÂ² - xÂ²
    
* **Divide & conquer** se solve karo
    
* **Space bilkul nahi lena hai** â€“ use variables only
    
* **Fast and clean solution** â€“ interviewer ko pasand aayega âœ…)
    

## ğŸ’ Bonus â€“ Why at least one duplicate and missing exists?

Because:

* You have numbers in `[1, n]`
    
* But one number repeats â†’ **Someone must be missing**
    
* It's like saying: "Ek seat pe do baithe, toh ek seat khali reh gayi!"
    

## ğŸ’ Final Thoughts:

This problem is a perfect example of using **math to optimize space**.  
Instead of searching element-by-element, we used **sum tricks** to calculate the answer with clean logic.

ğŸ“Œ **Kabhi kabhi soch seedhi nahi hoti â€“ lekin smart hoti hai**

---

### 2ï¸âƒ£**Count inversions in an array**

ğŸ”¸ Problem Statement:

Given an array of N integers, count the inversion of the array (using [merge-sort](https://takeuforward.org/data-structure/merge-sort-algorithm/))[.](https://takeuforward.org/data-structure/merge-sort-algorithm/)

What is an inversion of an array? Definition: for all i & j &lt; size of array, if i [&lt; j then](https://takeuforward.org/data-structure/merge-sort-algorithm/) you have to find pair (A\[i\],A\[j\]) such that A\[j\] &lt; A\[i\].

```plaintext
Example 1:
Input Format: N = 5, array[] = {1,2,3,4,5}
Result: 0
Explanation: we have a sorted array and the sorted array has 0 inversions as for i < j you will never find a pair such that A[j] < A[i]. More clear example: 2 has index 1 and 5 has index 4 now 1 < 5 but 2 < 5 so this is not an inversion.

Example 2:
Input Format: N = 5, array[] = {5,4,3,2,1}
Result: 10
Explanation: we have a reverse sorted array and we will get the maximum inversions as for i < j we will always find a pair such that A[j] < A[i]. Example: 5 has index 0 and 3 has index 2 now (5,3) pair is inversion as 0 < 2 and 5 > 3 which will satisfy out conditions and for reverse sorted array we will get maximum inversions and that is (n)*(n-1) / 2.For above given array there is 4 + 3 + 2 + 1 = 10 inversions.

Example 3:
Input Format: N = 5, array[] = {5,3,2,1,4}
Result: 7
Explanation: There are 7 pairs (5,1), (5,3), (5,2), (5,4),(3,2), (3,1), (2,1) and we have left 2 pairs (2,4) and (1,4) as both are not satisfy our condition. 
```

### ğŸ“ Real-Life Example:

Imagine a queue of students standing in height order for a class photo. Normally, **shorter students** should stand in front (sorted order).  
If a **taller student** stands in front of a **shorter one**, that's **"inversion"** in our lineup!

> In DSA, thatâ€™s exactly what we call an *inversion* in an array.

## ğŸ“Trick to Remember:

> "Whenever a **bigger number comes before** a **smaller one**, inversion mil gaya bhai!"

## ğŸ’  Brute Force Approach:

### Logic:

* Run 2 nested loops (`i` and `j`)
    
* Check every pair `(i, j)` where `i < j`
    
* Count if `arr[i] > arr[j]`
    

```java
class Solution {
    public long numberOfInversions(int[] nums) {
        int n = nums.length;
        long count = 0;
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] > nums[j]) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

### ğŸ“Time Complexity: O(NÂ²)

### ğŸ“ Space Complexity: O(1)

> âŒ Not suitable for large arrays!

## ğŸ’ Optimal Approach â€“ Using Modified Merge Sort

## ğŸ“ Idea

While merging two sorted halves, if any element from **right half** is **smaller** than from **left**, then all elements from `left[i]` to `mid` are greater than `right[j]` â€“ so count them as inversions.

## ğŸ“Dry Run Kar Ke Samjho:

Letâ€™s say we are merging two sorted subarrays:  
`Left: [2, 5]` and `Right: [1, 3]`  
While comparing 2 & 1 â†’ 2 &gt; 1 â†’ means 2 and 5 are greater than 1 â†’ count += 2

```java
public class Solution {
    public long numberOfInversions(int[] nums) {
        return mergeSortCount(nums, 0, nums.length - 1);
    }

    private long mergeSortCount(int[] arr, int low, int high) {
        long cnt = 0;
        if (low < high) {
            int mid = (low + high) / 2;
            cnt += mergeSortCount(arr, low, mid);
            cnt += mergeSortCount(arr, mid + 1, high);
            cnt += merge(arr, low, mid, high);
        }
        return cnt;
    }

    private long merge(int[] arr, int low, int mid, int high) {
        List<Integer> temp = new ArrayList<>();
        int left = low, right = mid + 1;
        long cnt = 0;
        while (left <= mid && right <= high) {
            if (arr[left] <= arr[right]) {
                temp.add(arr[left++]);
            } else {
                temp.add(arr[right++]);
                cnt += (mid - left + 1);
            }
        }
        while (left <= mid) temp.add(arr[left++]);
        while (right <= high) temp.add(arr[right++]);
        for (int i = low; i <= high; i++) arr[i] = temp.get(i - low);
        return cnt;
    }
}
```

### ğŸ“Time Complexity: O(N log N)

### ğŸ“ Space Complexity: O(1)

> âœ… Efficient even for large arrays. Merge Sort is

### ğŸ’ (Hinglish :

* **Inversion ka matlab hai** â€“ jab koi bada number pehle ho aur chhota baad mein ho (`i < j` but `arr[i] > arr[j]`)
    
* Brute force chalega small inputs ke liye, but large inputs me timeout milega
    
* Merge sort ko modify karke hum inversions count kar sakte hai during merge phase â€“ bina extra loop ke
    
* Time Complexity `O(N log N)` = sorted array jaisa fast, easy to apply in interviews)
    

## ğŸ“Œ Final Takeaway:

If you're given a problem to count inversion in an array:

* Brute force = simple, but slow
    
* Merge sort = fast and optimal
    

> "Inversions count batata hai kitna unordered hai array â€” jaise school line me sab height wise khade nahi hue ho "

## âœï¸ Final Notes:

If you're just starting your DSA journey like me, don't worry if you donâ€™t get it perfect the first time.  
**Visualize â†’ Dry Run â†’ Optimize.**  
Stay consistent, and letâ€™s crack every problem from brute to optimal! ğŸ’ª

### ğŸ™ Special Thanks

A heartfelt thank you to [**<mark>Rajvikraaditya Sir</mark>**](https://www.linkedin.com/in/rajstriver/) for creating and sharing such an incredible DSA resource with the community <mark>(takeuforward)</mark>. Your structured approach has made DSA more accessible and less intimidating for thousands of learners like me.

If this helped you, do share it with your fellow DSA learners.  
Comment with your doubts â€” Iâ€™d love to answer and grow together ğŸŒ±

âœï¸ [**Payal Kumari**](https://www.linkedin.com/in/payalkumari10/) ğŸ‘©â€ğŸ’»  
*My 27-Day DSA Journey with Striverâ€™s Sheet! <mark>#dsawithpayal</mark>*

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1753634896961/6b016a70-279d-4fe0-8145-ee021ea130c9.jpeg align="center")

%[https://youtu.be/2D0D8HE6uak] 

%[https://youtu.be/AseUmwVNaoY?si=ZP3opmgjlxTRdSvo]